# Catalog

V, L, A, Set, Category, Class, Universe, Axiomatic Theory underlying QIS (ISACUE [Identifier, Sets, Axiomatic, Categories, Universal, Elements]) Serialization Encapsulation and Run-Time Catalog-Source Generation, Compilation, and Execution.

A system by which a single PE (known as a QIS - Executable File,) contains within itself the serialized (with QIS Protocol and Form,) state of a complete PE source-code, which upon execution it processes and seamlessly substitutes for itself upon completion.

This is a needed part of the process. As proper Cataloging requires both Run-Time & File-Time Process Benchmarking of subset data segments between context of execution and identifiers (Being a Class, Method, Member, Field naming mechanic either a variable or constant,) which will then further affinities by means of segregated subsets of in/Out put differences and their respective efficacy of valuation while juncture of co & domain function results remain intersectant. As such we determine which patterns, variations of input, variations of output, give which results and are deemed a difference while maintaining result set equivalency. (With Time, Tick, Load, Core, Size) all measured with retrospective causation accounted for by means of mathematic axiom or theory - we may allude towards automated permeable sets alterations which would arise quantitative gains dreadlessly unwavering results. All of which, once again is reintroduced unto itself by means of categorization, affinity set formation, and eventually alteration to Serialized Binary Executable in place of QIS.

One could very well state quite a bit, however, there is closure in the matter, path theory is not over-looked. And the added benefit of becoming highly efficient on Q# operation systems (Due to Limit and Derivation utilization prominence - traversing permeable function space...)

I would like to make some nomenclature for the approach clear.

I am in -favor of the current means of formation.

https://github.com/2652660/Mathematics/blob/master/Arithmetic/Multiplication.CS
https://github.com/2652660/Mathematics/blob/master/Arithmetic/Factor.CS
https://github.com/2652660/Mathematics/blob/master/Arithmetic/Product.CS

Class Multiplication holds Factor, set by means of members Multiplicand and Multiplier, which; at set are not operated - rather passed into Factor - by sames means of access at such degree - but are operand upon calling unto Factor; Product - which is a resultant class Product given Multiplicand and Multiplier - having a Value member which then Adds unto Zero a Multiplicand, Multiplier times - upon call. This in my realm of thought will, even upon error, consistently give a same physical attempted result - and represent holding and doing only what it is, would, could, should, must, and shall be.

I was thinking heavily on the matter. Imagine I wrote 12 on a page and handed you the page expectant of you to know it a Product of Factors 6-Multiplicand 2-Multiplier. But to transfer the workload, by allowing you to watch me do the work, we receive a well-formed strictly typed resultant with self-efficacy and completion logically as a unit.

If any ideas arise please relay them, irregardless to notion of importance or relevance even.

Before I forgot - C# has built-in processes for automated translation of a serialized class to and between; JSON, XML, XSD, XSLT, XHTML, Schema, C#, & VB all of which are Cross-System Native Supported (Mostly,) thus QIS may need take 2 Files - Executable & Module/Data/Form; but...a desire to minimize the respective latter modification at such point had idealized embedding. So, I am thinking something like an ISO or Bootable? How do I achieve with one File, and one Click what two Files and one Click are needed for? Maybe...

P.S. QIS may be like a Sponge. If within itself it has no Module/Data/Form, when executed it would "Absorb," the local Module, recompile and replace itself - with a new PE, which if another Module/Data/Form is adjacent (per-se the same folder with it,) it would attempt to recompile itself with the new module (and if successful,) "absorb," the new File, while "wringing out/expelling" the previous. (Similar to rotation of a LinkedList...) in as such there are points between where you have one Stand-alone PE, which has the ability to act in such a way as a PE with External Resource.

A QVIS (V for Volute) will have four states.
1. Module Negative (Will Absorb without Expulsion a Module - deleting the Module File, it's last PE, and recompiling itself in its place.)
2. Module Positive (Will Absorb with Expulsion a new Module of successful Executability - deleting the Module File, it's last PE, and recompiling itself and previous Module File in its place,)
3. Polarizing Module Absorption / Expulsion (When Modules currently not installed and removed from Disk are within same Executable Directory/Observable Field of View)
4. Normal QIS Substitution Protocol (Only when Standalone [Module Positive] without adjacent valid Modules | Persistent Cyclic Redundancy Prevention Flag denies Module Validity [Possible Signature/Hash of Last Expelled Module])

I believe I will be going with the Module, QVIS, Persistent, QIS Model view to control the outcomes I orient objectively through programming.

Sincerely,

Mr. Rogers
